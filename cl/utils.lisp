(in-package #:dependently-typed-cl.impl)

(defun constant-type-value (type default)
  (optima:match (cl-form-types:nth-value-type (typexpand type) 0)
    ((list 'eql value)
     value)
    ((list 'member value)
     value)
    ((list 'specializing (or 'integer 'rational 'real 'float 'single-float 'double-float)
           low high)
     (if (and (numberp low)
              (numberp high)
              (= low high))
         low
         default))
    (_
     default)))

(defun eql-or-member-value (type default)
  (optima:match type
    ((list 'eql value)
     value)
    ((list 'member value)
     value)
    (_
     default)))

(defun closed-numeric-class-of (object)
  (typecase object
    (integer      'integer)
    (rational     'rational)
    (short-float  'short-float)
    (single-float 'single-float)
    (long-float   'long-float)
    (double-float 'double-float)
    (real         'real)
    ((complex single-float) '(complex single-float))
    ((complex double-float) '(complex double-float))
    ((complex rational)     '(complex rational))))

(defun simple-numeric-type (type)
  (alexandria:eswitch (type :test #'subtypep)
    ('fixnum       'fixnum)
    ('integer      'integer)
    ('rational     'rational)
    ('short-float  'short-float)
    ('single-float 'single-float)
    ('long-float   'long-float)
    ('double-float 'double-float)
    ('real         'real)
    ('(complex single-float) '(complex single-float))
    ('(complex double-float) '(complex double-float))
    ('(complex rational)     '(complex rational))
    ('number       'number)))

(defun max-type (type-1 type-2)
  (cond ((subtypep type-1 type-2)
         type-2)
        ((subtypep type-2 type-1)
         type-1)
        ((or (alexandria:type= type-1 'double-float)
             (alexandria:type= type-2 'double-float))
         'double-float)
        ((or (alexandria:type= type-1 'single-float)
             (alexandria:type= type-2 'single-float))
         'single-float)
        ;; At this point, none of the types are floats
        ;; FIXME: Operate better on impl with other float types
        ((and (subtypep type-1 '(unsigned-byte *))
              (subtypep type-2 '(signed-byte *)))
         (loop :for num-bits :in '(8 16 32 64)
               :if (subtypep type-1 `(signed-byte ,num-bits))
                 :do (return-from max-type `(signed-byte ,num-bits))
               :finally (return-from max-type 'single-float)))
        ((and (subtypep type-1 '(signed-byte *))
              (subtypep type-2 '(unsigned-byte *)))
         (loop :for num-bits :in '(8 16 32 64)
               :if (subtypep type-2 `(signed-byte ,num-bits))
                 :do (return-from max-type `(signed-byte ,num-bits))
               :finally (return-from max-type 'single-float)))
        (t
         (error "Don't know how to find MAX-TYPE of ~S and ~S" type-1 type-2))))

(defun vector-type-element-type (vector-type &optional (simplify-and-type t))
  (optima:ematch (typexpand vector-type)
    ((list* 'specializing 'array element-type _)
     element-type)
    ((list 'eql vector)
     (array-element-type vector))
    ((list 'member vector)
     (array-element-type vector))
    ((list* 'and _)
     (if simplify-and-type
         (vector-type-element-type (simplify-and-type vector-type) nil)
         (error "Tried simplifying already")))))

(defun vector-type-length (vector-type &optional (simplify-and-type t))
  (optima:ematch (typexpand vector-type)
    ((list* 'specializing 'array _ _ (list length) _)
     length)
    ((list 'eql vector)
     (array-total-size vector))
    ((list 'member vector)
     (array-total-size vector))
    ((list* 'and _)
     (if simplify-and-type
         (vector-type-length (simplify-and-type vector-type) nil)
         (error "Tried simplifying already")))))
