(in-package #:dependently-typed-cl.impl)

(def-dept-fun dept:coerce-number (number type)
    (eql-or-member-value type t)
  (cl:coerce number type))

(macrolet ((def (fn cl-fn)
               `(def-dept-fun ,fn (a b)
                    `(values ,@(mapcar
                                #'typo:ntype-type-specifier
                                (typo:infer-ntypes ',cl-fn
                                                   (list (typo:type-specifier-ntype a)
                                                         (typo:type-specifier-ntype b)))))
                  (,cl-fn a b))))
  (def dept:add      cl:+)
  (def dept:subtract cl:-)
  (def dept:multiply cl:*)
  (def dept:divide   cl:/))

(macrolet ((def (fn cl-fn)
               `(def-dept-fun ,fn (number divisor)
                    `(values ,@(mapcar
                                #'typo:ntype-type-specifier
                                (typo:infer-ntypes
                                 ',cl-fn
                                 (list (typo:type-specifier-ntype number)
                                       (typo:type-specifier-ntype divisor)))))
                  (,cl-fn number divisor))))
  (def dept:mod cl:mod)
  (def dept:rem cl:rem))

(def-dept-fun dept:1+ (number)
    `(values ,(let ((number-value (constant-type-value number :unknown)))
                (declare (optimize debug))
                (cond ((numberp number-value)
                       `(eql ,(1+ number-value)))
                      ((subtypep number 'number)
                       (simple-numeric-type number))
                      ((type= t number)
                       t)
                      (t
                       nil)))
             &optional)
  (cl:1+ number))

(def-dept-fun dept:1- (number)
    `(values ,(let ((number-value (constant-type-value number :unknown)))
                (declare (optimize debug))
                (cond ((numberp number-value)
                       `(eql ,(1- number-value)))
                      ((subtypep number 'number)
                       (simple-numeric-type number))
                      ((type= t number)
                       t)
                      (t
                       nil)))
             &optional)
  (cl:1- number))

(def-dept-fun dept:mod (number divisor)
    (let ((number  (or (constant-type-value number nil)
                       (closed-numeric-class-from-type number)))
          (divisor (or (constant-type-value divisor nil)
                       (closed-numeric-class-from-type divisor))))
      (cond ((and (numberp number) (numberp divisor))
             `(eql ,(mod number divisor)))
            ((and number divisor)
             (max-type number divisor))
            (t
             'real)))
  (mod number divisor))

(def-dept-fun dept:rem (number divisor)
    (let ((number  (or (constant-type-value number nil)
                       (closed-numeric-class-from-type number)))
          (divisor (or (constant-type-value divisor nil)
                       (closed-numeric-class-from-type divisor))))
      (cond ((and (numberp number) (numberp divisor))
             `(eql ,(rem number divisor)))
            ((and number divisor)
             (max-type number divisor))
            (t
             'real)))
  (rem number divisor))

(macrolet ((def (fn cl-fn)
               `(def-dept-fun ,fn (number)
                    `(values ,(cond ((constant-type-value number nil)
                                     `(eql ,(,cl-fn (constant-type-value number nil))))
                                    ((subtypep number 'integer)
                                     #+sbcl '(single-float -1.0 1.0)
                                     #-sbcl `(or (rational -1 1)
                                                 (float -1.0 1.0)))
                                    ((subtypep number 'single-float)
                                     '(single-float -1.0 1.0))
                                    ((subtypep number 'double-float)
                                     '(double-float -1.0 1.0))
                                    (t
                                     number))
                             &optional)
                  (,cl-fn number))))
  (def dept:sin cl:sin)
  (def dept:cos cl:cos))

(macrolet ((def (fn cl-fn)
               `(def-dept-fun ,fn (number)
                    `(values ,@(mapcar
                                #'typo:ntype-type-specifier
                                (typo:infer-ntypes
                                 ',cl-fn
                                 (list (typo:type-specifier-ntype number)))))
                  (,cl-fn number))))
  (def dept:tan cl:tan)
  (def dept:sinh cl:sinh)
  (def dept:cosh cl:cosh)
  (def dept:tanh cl:tanh)

  (def dept:asinh cl:asinh)
  (def dept:acosh cl:acosh)
  (def dept:atanh cl:atanh)

  (def dept:asin cl:asin)
  (def dept:acos cl:acos))

(def-dept-fun dept:atan (y &optional (x nil xp))
    (let ((y (or (constant-type-value y nil)
                 (alexandria:switch (y :test #'subtypep)
                   ('integer 'double-float)
                   ('single-float 'single-float)
                   ('double-float 'double-float)
                   ('(complex single-float) '(complex single-float))
                   ('(complex double-float) '(complex double-float))
                   (t 'number))))
          (x (or (constant-type-value x nil)
                 (alexandria:switch (x :test #'subtypep)
                   ('integer 'double-float)
                   ('single-float 'single-float)
                   ('double-float 'double-float)
                   ('(complex single-float) '(complex single-float))
                   ('(complex double-float) '(complex double-float))
                   (t 'real)))))
      (ecase xp
        ((t)
         `(values ,(if (and (numberp x) (numberp y))
                       `(eql ,(atan y x))
                       (max-type x y))
                  &optional))
        ((nil)
         `(values ,(if (numberp y)
                       `(eql ,(atan y))
                       y)
                  &optional))))
  (if xp
      (cl:atan y x)
      (cl:atan y)))

(def-dept-fun dept:log (number &optional (base nil basep))
    (let ((number (or (constant-type-value number nil)
                      (alexandria:switch (number :test #'subtypep)
                        ('integer 'double-float)
                        ('single-float 'single-float)
                        ('double-float 'double-float)
                        ('(complex single-float) '(complex single-float))
                        ('(complex double-float) '(complex double-float))
                        (t 'number))))
          (base (or (constant-type-value base nil)
                    (alexandria:switch (base :test #'subtypep)
                      ('integer 'double-float)
                      ('single-float 'single-float)
                      ('double-float 'double-float)
                      ('(complex single-float) '(complex single-float))
                      ('(complex double-float) '(complex double-float))
                      (t 'real)))))
      (ecase basep
        ((t)
         `(values ,(if (and (numberp base) (numberp number))
                       `(eql ,(log number base))
                       (max-type base number))
                  &optional))
        ((nil)
         `(values ,(if (numberp number)
                       `(eql ,(log number))
                       number)
                  &optional))))
  (if basep
      (cl:log number base)
      (cl:log number)))
