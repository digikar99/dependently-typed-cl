(in-package #:dependently-typed-cl.impl)

(deftype dept:list () 'cl:list)

(deftype dept:list-of (&rest element-types)
  (if element-types
      `(cons ,(if (eq 'cl:* (first element-types))
                  cl:t
                  (first element-types))
             (dept:list-of ,@(rest element-types)))
      'null))

(deftype dept:list-of* (element-type length)
  `(dept:list-of ,@(make-list length :initial-element element-type)))

(def-dept-fun dept:list (&rest args)
    `(values (dept:list-of ,@args) &optional)
  (apply #'list args))

(def-dept-fun dept:car (list)
    `(values ,(let ((list-value (constant-type-value list :unknown)))
                (cond ((listp list-value)
                       `(eql ,(car list-value)))
                      ((subtypep list 'cons)
                       (optima:ematch (typexpand list)
                         ((list 'specializing 'cons car-type _)
                          car-type)))
                      ((subtypep list 'null)
                       'null)
                      ((subtypep 'list list)
                       t)))
             &optional)
  (car list))

(def-dept-fun dept:cdr (list)
    `(values ,(let ((list-value (constant-type-value list :unknown)))
                (cond ((listp list-value)
                       `(eql ,(cdr list-value)))
                      ((subtypep list 'cons)
                       (optima:ematch (typexpand list)
                         ((list 'specializing 'cons _ cdr-type)
                          cdr-type)))
                      ((subtypep list 'null)
                       'null)
                      ((subtypep 'list list)
                       t)))
             &optional)
  (cdr list))

(def-dept-fun dept:nth (n list)
    (cond ((subtypep n 'unsigned-byte)
           `(values ,(let ((n-value (constant-type-value n :unknown)))
                       (if (integerp n-value)
                           (loop :with list-type := (cl-form-types:nth-value-type list 0)
                                 :repeat n-value
                                 :do (cond ((subtypep list-type 'cons)
                                            (setq list-type
                                                  (cl-form-types:nth-value-type
                                                   (infer-return-type 'dept:cdr list-type)
                                                   0)))
                                           ((subtypep list-type 'null)
                                            (return 'null))
                                           (t
                                            (return t)))
                                 :finally (return (cl-form-types:nth-value-type
                                                   (infer-return-type 'dept:car list-type)
                                                   0)))
                           ()))
                    &optional))
          ((subtypep 'number n)
           `(values t &optional))
          (t
           nil))
  (let ((list list))
    (dotimes (i n)
      (setq list (cdr list)))
    (car list)))

(macrolet ((def (name number)
               `(def-dept-fun ,name (list)
                    (infer-return-type 'dept:nth `(eql ,,number) list)
                  (dept:nth ,number list))))
  (def dept:first   0)
  (def dept:second  1)
  (def dept:third   2)
  (def dept:fourth  3)
  (def dept:fifth   4)
  (def dept:sixth   5)
  (def dept:seventh 6)
  (def dept:eighth  7)
  (def dept:ninth   8)
  (def dept:tenth   9))
